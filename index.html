<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Chinese Character - Anki Mode</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --char-size-desktop: 280px;
      --char-size-mobile: 220px;
    }
    html, body { height: 100%; width: 100%; overflow-x: hidden; }
    body {
      display: flex; flex-direction: column;
      justify-content: space-between;
      align-items: center; margin: 0;
      padding: 50px 10px 20px 10px;
      box-sizing: border-box; background-color: #fefefe;
      font-family: "Noto Serif TC", "Microsoft JhengHei", sans-serif;
    }
    #status-container {
      position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
      display: flex; align-items: center; gap: 10px;
      font-size: 18px; color: #333;
      white-space: nowrap;
    }
    #sync-status-indicator { font-size: 14px; font-weight: bold; }

    #search-btn, #edit-btn {
      position: absolute;
      top: 15px;
      font-size: 26px;
      color: #555;
      text-decoration: none;
      transition: color 0.2s;
      cursor: pointer;
    }
    #search-btn { left: 20px; }
    #edit-btn { right: 20px; }
    #search-btn:hover, #edit-btn:hover {
      color: #1e90ff;
    }

    .main-content, .footer-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
    }
    .main-content {
      margin-top: 0;
      opacity: 0; 
      transition: opacity 0.3s ease-in-out;
    }

    #char {
      font-size: var(--char-size-desktop); font-family: "Noto Serif TC", serif;
      display: flex; justify-content: center; align-items: center;
      min-width: 350px; min-height: 350px;
      margin-bottom: 5px;
    }
    #char-actions {
        display: flex;
        gap: 30px;
        margin-top: 10px; /* Added margin */
    }
    #speak-btn, #stroke-btn {
      background: none; border: none; color: #333; font-size: 40px;
      cursor: pointer; padding: 0; line-height: 1; transition: color 0.2s, opacity 0.2s;
    }
    #speak-btn:hover, #stroke-btn:hover { color: #1e90ff; }
    .buttons {
      display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;
      justify-content: center;
    }
    button {
      font-size: 18px; padding: 10px 15px; border: none; border-radius: 6px;
      color: white; background-color: #1e90ff; cursor: pointer; min-width: 100px;
    }
    button:hover { opacity: 0.85; }
    .again { background-color: #e74c3c; } .hard { background-color: #f39c12; }
    .good { background-color: #2ecc71; } .easy { background-color: #3498db; }
    
    #definitions-container {
      max-width: 600px;
      width: 95%;
      margin-top: 10px;
      padding: 5px 15px;
      background-color: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      text-align: left;
      font-size: 16px;
      line-height: 1.7;
      max-height: 40vh; /* Increased max-height */
      overflow-y: auto;
      display: none;
    }
    #definitions-container h4 {
      margin: 10px 0 5px 0;
      font-size: 24px;
      font-weight: normal;
      color: #1e90ff;
      border-bottom: 1px solid #dee2e6;
      padding-bottom: 5px;
    }
    #definitions-container ol {
      padding-left: 25px;
      margin: 0;
    }
    #definitions-container li {
      margin-bottom: 12px;
    }
    #definitions-container .part-of-speech {
      font-weight: bold;
      color: #343a40;
    }
    #definitions-container .example {
      color: #6c757d;
      font-style: italic;
      margin-top: 5px;
      display: block;
    }

    #practice-container {
      display: none;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      margin-top: 5px;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }
    #stroke-order-animation, #handwriting-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    #stroke-order-animation img {
      max-width: 300px;
      height: auto;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    #handwriting-canvas {
      background-color: #fff;
      border: 1px solid #999;
      cursor: crosshair;
      border-radius: 5px;
    }
    #handwriting-controls button {
      background-color: #6c757d;
      min-width: 120px;
    }

    @media (max-width: 768px) {
      body {
        padding: 60px 10px 20px 10px;
      }
      #search-btn, #edit-btn {
        font-size: 24px;
      }
      #char {
        font-size: var(--char-size-mobile);
        min-width: 280px;
        min-height: 280px;
      }
      #speak-btn, #stroke-btn { font-size: 32px; }
      .buttons { gap: 5px; }
      button { font-size: 16px; padding: 8px 10px; min-width: 80px; }

      #practice-container {
        flex-direction: column;
        align-items: center;
      }
      #stroke-order-animation img {
        max-width: 280px;
      }
    }
  </style>
</head>
<body>
  <div id="status-container">
    <span id="status">Loading...</span>
    <span id="sync-status-indicator"></span>
  </div>
  <a id="search-btn" aria-label="Search Character"><i class="bi bi-search"></i></a>
  <a href="edit.html" id="edit-btn" aria-label="Edit Deck & Settings"><i class="bi bi-gear-fill"></i></a>
  
  <div class="main-content">
    <div id="char">Loading...</div>
    <div id="definitions-container"></div>
    <div id="char-actions">
        <button id="speak-btn" onclick="speakCharacter()" aria-label="Speak"><i class="bi bi-volume-up-fill"></i></button>
        <button id="stroke-btn" onclick="showStrokeOrder()" aria-label="Show Stroke Order & Practice"><i class="bi bi-pen-fill"></i></button>
    </div>
    <div id="practice-container">
      <div id="stroke-order-animation"></div>
      <div id="handwriting-area">
        <canvas id="handwriting-canvas"></canvas>
        <div id="handwriting-controls">
          <button id="clear-canvas-btn">Clear</button>
        </div>
      </div>
    </div>
  </div>

  <div class="footer-controls">
    <div class="buttons">
      <button id="btn-again" class="again" onclick="rate('again')">Again<br><small>...</small></button>
      <button id="btn-hard" class="hard" onclick="rate('hard')">Hard<br><small>...</small></button>
      <button id="btn-good" class="good" onclick="rate('good')">Good<br><small>...</small></button>
      <button id="btn-easy" class="easy" onclick="rate('easy')">Easy<br><small>...</small></button>
    </div>
  </div>

  <script>
    let cards = {};
    let currentCard = null;
    const synth = window.speechSynthesis;
    let chineseVoice = null;
    let isStrokeVisible = false;
    
    const MOEDICT_API_BASE = 'https://www.moedict.tw/raw/';
    const GIST_FILENAME = 'progress.json';
    const CONSTANTS = {
      AGAIN_INTERVAL: 1, MIN_GOOD_INTERVAL: 10, MIN_EASE: 130, EASY_INITIAL_DAYS: 3,
      EASY_MULTIPLIER: 1.3, HARD_MULTIPLIER: 1.2, MIN_DAY_INTERVAL: 1440,
      EASE_PENALTY_AGAIN: 20, EASE_PENALTY_HARD: 15, EASE_BONUS_EASY: 20
    };
    
    const GIST_API_BASE = 'https://api.github.com/gists/';
    let accessToken = '';
    let gistId = '';

    const footerControls = document.querySelector('.footer-controls');

    // --- Handwriting Canvas Logic ---
    const canvas = document.getElementById('handwriting-canvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0, lastY = 0;

    function setupCanvas() {
        const size = window.innerWidth < 768 ? 280 : 300;
        canvas.width = size;
        canvas.height = size;
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
    }
    function drawBackgroundCharacter() {
        if (!currentCard || !currentCard.char) return;
        const char = currentCard.char;
        const size = canvas.width * 0.8;
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#333';
        ctx.font = `${size}px "Noto Serif TC", serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(char, canvas.width / 2, canvas.height / 2);
        ctx.globalAlpha = 1.0;
    }
    function getCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        }
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function startDrawing(e) {
        e.preventDefault();
        isDrawing = true;
        const { x, y } = getCoordinates(e);
        [lastX, lastY] = [x, y];
    }
    function draw(e) {
        if (!isDrawing) return;
        e.preventDefault();
        const { x, y } = getCoordinates(e);
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        [lastX, lastY] = [x, y];
    }
    function stopDrawing() { isDrawing = false; }
    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackgroundCharacter();
    }
    
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    canvas.addEventListener('touchstart', startDrawing, { passive: false });
    canvas.addEventListener('touchmove', draw, { passive: false });
    canvas.addEventListener('touchend', stopDrawing);
    document.getElementById('clear-canvas-btn').addEventListener('click', clearCanvas);
    window.addEventListener('resize', setupCanvas);
    // --- End of Handwriting Canvas Logic ---

    function searchForChar() {
      const charToFind = prompt("Enter a character to search for:");
      if (!charToFind || charToFind.trim().length !== 1) {
        if (charToFind !== null) alert("Please enter a single character.");
        return;
      }
      
      const foundCard = cards[charToFind.trim()];
      if (foundCard) {
        if (isStrokeVisible) showStrokeOrder(); 
        
        currentCard = foundCard;
        document.getElementById("char").innerHTML = currentCard.char;
        document.getElementById('definitions-container').style.display = 'none';
        document.getElementById('definitions-container').innerHTML = '';
        document.getElementById('char').style.display = 'flex';
        document.getElementById('practice-container').style.display = 'none';
        footerControls.style.display = 'flex';

        toggleControls(true);
        updateButtonLabels();
      } else {
        alert(`Character "${charToFind}" not found in your deck.`);
      }
    }

    function updateSyncStatus(message, isError = false) {
      const statusEl = document.getElementById('sync-status-indicator');
      if (!accessToken || !gistId) {
        statusEl.textContent = 'Local';
        statusEl.style.color = '#f39c12';
        return;
      }
      statusEl.textContent = 'Sync';
      statusEl.style.color = isError ? '#e74c3c' : '#2ecc71';
    }

    async function saveToCloud() {
      if (!accessToken || !gistId) return;
      try {
        const response = await fetch(`${GIST_API_BASE}${gistId}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `token ${accessToken}`, 'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ files: { [GIST_FILENAME]: { content: JSON.stringify(cards) } } })
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        updateSyncStatus('Synced', false);
      } catch (error) {
        console.error('Failed to save to Gist:', error);
        updateSyncStatus('Sync Failed', true);
      }
    }

    async function loadFromCloud() {
      if (!accessToken || !gistId) return false;
      try {
        const response = await fetch(`${GIST_API_BASE}${gistId}`, {
          method: 'GET',
          headers: { 'Authorization': `token ${accessToken}`, 'Accept': 'application/vnd.github.v3+json' }
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        if (data.files && data.files[GIST_FILENAME]) {
            const content = data.files[GIST_FILENAME].content;
            cards = content ? JSON.parse(content) : {};
        }
        updateSyncStatus('Connected', false);
        return true;
      } catch (error) {
        console.error('Failed to load from Gist:', error);
        updateSyncStatus('Connection Failed', true);
        return false;
      }
    }
    
    function loadCredentials() {
      accessToken = localStorage.getItem('ankiAccessToken') || '';
      gistId = localStorage.getItem('ankiGistId') || '';
    }
    
    function setChineseVoice() {
        const voices = synth.getVoices();
        chineseVoice = voices.find(voice => voice.lang.includes('zh-TW') || voice.lang.includes('zh-CN')) || voices.find(voice => voice.lang.includes('zh'));
    }
    if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = setChineseVoice;
    setChineseVoice();
    
    function renderDefinitions(data) {
        const container = document.getElementById('definitions-container');
        container.innerHTML = '';

        if (!data || !data.heteronyms) return;

        let content = '';
        data.heteronyms.forEach(h => {
            if (!h.definitions || h.definitions.length === 0) return;

            content += `<h4>${h.bopomofo}</h4>`;
            content += `<ol>`;
            h.definitions.forEach(def => {
                content += `<li>`;
                if (def.type) content += `<span class="part-of-speech">[${def.type}]</span> `;
                content += def.def;

                if (def.example && def.example.length > 0) {
                    def.example.forEach(ex => { content += `<span class="example">例：${ex}</span>`; });
                }
                if (def.quote && def.quote.length > 0) {
                    def.quote.forEach(q => { content += `<span class="example">引：${q}</span>`; });
                }
                content += `</li>`;
            });
            content += `</ol>`;
        });

        if (content) {
            container.innerHTML = content;
            container.style.display = 'block';
        } else {
            container.style.display = 'none';
        }
    }
    
    async function fetchAndDisplayDetails(char) {
        const container = document.getElementById('definitions-container');
        container.innerHTML = '<h4>Loading...</h4>';
        container.style.display = 'block';

        try {
            if (!char) { container.innerHTML = '<h4>Character missing</h4>'; return; }
            const resp = await fetch(MOEDICT_API_BASE + encodeURIComponent(char));
            if (!resp.ok) { container.innerHTML = `<h4>API Error: HTTP ${resp.status}</h4>`; return; }
            
            const data = await resp.json();
            renderDefinitions(data);
        } catch (error) { 
            console.error("Moedict API failed:", error); 
            container.innerHTML = `<h4>API call failed</h4>`;
        }
    }

    function speakCharacter() {
        if (!currentCard || !currentCard.char) return;
        if (synth.speaking) synth.cancel();
        const utterance = new SpeechSynthesisUtterance(currentCard.char);
        utterance.voice = chineseVoice;
        utterance.lang = 'zh-TW';
        utterance.rate = 0.8;
        synth.speak(utterance);
        
        if (!isStrokeVisible) {
            fetchAndDisplayDetails(currentCard.char);
        }
    }
    
    function charToHex(char) { return char ? char.codePointAt(0).toString(16).toLowerCase() : ''; }

    function showStrokeOrder() {
        const charElement = document.getElementById('char');
        const practiceContainer = document.getElementById('practice-container');
        const strokeBtn = document.getElementById('stroke-btn');
        const definitionsEl = document.getElementById('definitions-container');
        if (!currentCard || !currentCard.char) return;

        if (isStrokeVisible) {
            practiceContainer.style.display = 'none';
            charElement.style.display = 'flex';
            footerControls.style.display = 'flex';
            charElement.textContent = currentCard.char;
            strokeBtn.querySelector('i').className = 'bi bi-pen-fill';
            isStrokeVisible = false;
        } else {
            charElement.style.display = 'none';
            footerControls.style.display = 'none';
            definitionsEl.style.display = 'none';
            const hex = charToHex(currentCard.char);
            if (!hex) {
              alert('Cannot get character Unicode.');
              return;
            }
            const url = `https://www.twpen.com/bishun-animation/${hex}-stroke-order.gif`;
            document.getElementById('stroke-order-animation').innerHTML = `<img src="${url}" alt="${currentCard.char} Stroke Order Animation">`;
            
            setupCanvas();
            clearCanvas();

            practiceContainer.style.display = 'flex';
            strokeBtn.querySelector('i').className = 'bi bi-x-circle-fill';
            isStrokeVisible = true;
        }
    }

    function minutesToMs(mins) { return mins * 60 * 1000; }
    function formatInterval(minutes) {
      if (minutes < 60) return `${Math.max(1, Math.round(minutes))}m`;
      const hours = minutes / 60;
      return hours < 24 ? `${Math.round(hours)}h` : `${Math.round(hours / 24)}d`;
    }
    function saveProgress() {
      if (accessToken && gistId) saveToCloud();
      else localStorage.setItem("ankiCards", JSON.stringify(cards));
    }
    async function loadProgress() {
      const cloudSuccess = await loadFromCloud();
      if (!cloudSuccess) {
        const saved = localStorage.getItem("ankiCards");
        if (saved) cards = JSON.parse(saved);
      }
      updateSyncStatus();
    }
    function calculateNextState(card, action) {
        let newInterval, newEase = card.ease;
        const good = card.interval < CONSTANTS.MIN_GOOD_INTERVAL ? CONSTANTS.MIN_GOOD_INTERVAL : card.interval * (card.ease / 100);
        switch(action) {
            case "again": newInterval = CONSTANTS.AGAIN_INTERVAL; newEase = Math.max(CONSTANTS.MIN_EASE, newEase - CONSTANTS.EASE_PENALTY_AGAIN); break;
            case "hard": newInterval = (CONSTANTS.AGAIN_INTERVAL + good) / 2 * CONSTANTS.HARD_MULTIPLIER; newEase = Math.max(CONSTANTS.MIN_EASE, newEase - CONSTANTS.EASE_PENALTY_HARD); break;
            case "good": newInterval = good; break;
            case "easy": newInterval = (card.interval < CONSTANTS.MIN_DAY_INTERVAL ? CONSTANTS.MIN_DAY_INTERVAL * CONSTANTS.EASY_INITIAL_DAYS : good * CONSTANTS.EASY_MULTIPLIER); newEase += CONSTANTS.EASE_BONUS_EASY; break;
        }
        return { interval: Math.round(newInterval), ease: newEase };
    }
    function updateButtonLabels() {
        ['again', 'hard', 'good', 'easy'].forEach(action => {
            const small = document.getElementById(`btn-${action}`).querySelector('small');
            small.textContent = currentCard ? formatInterval(calculateNextState(currentCard, action).interval) : '---';
        });
    }
    function toggleControls(enabled) {
      [document.getElementById('speak-btn'), document.getElementById('stroke-btn')].forEach(btn => {
        btn.disabled = !enabled; btn.style.opacity = enabled ? 1.0 : 0.5;
        btn.style.cursor = enabled ? 'pointer' : 'default';
      });
    }
    async function initializeDeck() {
      await loadProgress();
      try {
        const response = await fetch("chars.txt");
        if (response.ok) {
            const text = await response.text();
            const chars = text.split(/\r?\n/).map(c => c.trim()).filter(c => c.length === 1);
            let newCardsAdded = chars.reduce((count, c) => {
              if (!cards[c]) { cards[c] = { char: c, interval: 0, ease: 250, due: Date.now() }; return count + 1; }
              return count;
            }, 0);
            if (newCardsAdded > 0) saveProgress();
        }
      } catch (error) { 
        console.error("chars.txt not found or failed to load.", error);
      } finally {
        updateStatus();
        if (Object.keys(cards).length > 0) {
            showNextCard();
        } else {
            document.getElementById("char").textContent = "Deck is empty. Add cards in \"Edit Deck & Settings\".";
            currentCard = null;
            toggleControls(false);
            updateButtonLabels();
        }
        document.querySelector('.main-content').style.opacity = 1;
      }
    }
    function updateStatus() {
      const total = Object.keys(cards).length;
      const dueNow = Object.values(cards).filter(c => c.due <= Date.now()).length;
      document.getElementById("status").textContent = `Due: ${dueNow} / Total: ${total}`;
    }
    function showNextCard() {
      document.getElementById('practice-container').style.display = 'none';
      document.getElementById('char').style.display = 'flex';
      footerControls.style.display = 'flex';
      isStrokeVisible = false;
      document.getElementById('stroke-btn').querySelector('i').className = 'bi bi-pen-fill';
      const definitionsEl = document.getElementById('definitions-container');
      definitionsEl.style.display = 'none';
      definitionsEl.innerHTML = '';
      
      const dueCards = Object.values(cards).filter(c => c.due <= Date.now());
      if (dueCards.length > 0) {
        currentCard = dueCards[Math.floor(Math.random() * dueCards.length)];
      } else if (Object.keys(cards).length > 0) {
        currentCard = Object.values(cards).sort((a, b) => a.due - b.due)[0];
      } else {
        currentCard = null;
      }
      
      if (currentCard) {
        document.getElementById("char").innerHTML = currentCard.char;
        toggleControls(true);
      } else {
        document.getElementById("char").textContent = "All cards reviewed for now!";
        toggleControls(false);
      }

      updateStatus(); 
      updateButtonLabels();
    }
    function rate(action) {
      if (!currentCard) return;
      const { interval, ease } = calculateNextState(currentCard, action);
      currentCard.interval = interval; currentCard.ease = ease;
      currentCard.due = Date.now() + minutesToMs(interval);
      saveProgress(); 
      showNextCard();
    }
    
    loadCredentials();
    setupCanvas();
    document.getElementById('search-btn').addEventListener('click', searchForChar);
    initializeDeck();
  </script>
</body>
</html>