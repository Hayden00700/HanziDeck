<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Chinese Character - Anki Mode</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons-webfont@latest/tabler-icons.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3/dist/hanzi-writer.min.js"></script>
  <style>
    :root {
      --char-size-desktop: 280px;
      --char-size-mobile: 220px;
    }
    html, body { height: 100%; width: 100%; overflow-x: hidden; }
    body {
      display: flex; flex-direction: column;
      align-items: center; margin: 0;
      padding: 50px 10px 150px 10px;
      box-sizing: border-box; background-color: #fefefe;
      font-family: "Noto Serif TC", "Microsoft JhengHei", sans-serif;
    }
    #status-container {
      position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
      display: flex; align-items: center; gap: 10px;
      font-size: 18px; color: #333;
      white-space: nowrap;
    }
    #sync-status-indicator { font-size: 14px; font-weight: bold; }

    #search-btn, #edit-btn {
      position: absolute;
      top: 15px;
      font-size: 26px;
      color: #555;
      text-decoration: none;
      transition: color 0.2s;
      cursor: pointer;
    }
    #search-btn { left: 20px; }
    #edit-btn { right: 20px; }
    #search-btn:hover, #edit-btn:hover {
      color: #1e90ff;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin-top: 0;
      opacity: 0; 
      transition: opacity 0.3s ease-in-out;
    }
    
    .footer-controls {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #fefefe;
      padding: 10px 0 20px 0;
      z-index: 100;
      border-top: 1px solid #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    #main-display-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      min-height: 350px;
    }

    #char {
      display: flex; 
      justify-content: center; 
      align-items: center;
      width: 350px; 
      height: 350px;
    }
    
    #char-actions-footer {
      display: flex;
      gap: 60px;
      margin-bottom: 15px;
    }
    
    #speak-btn, #stroke-btn {
      background: none; border: none; color: #333; font-size: 32px;
      cursor: pointer; padding: 0; line-height: 1; transition: color 0.2s, opacity 0.2s;
    }
    #speak-btn:hover, #stroke-btn:hover { color: #1e90ff; }
    
    .buttons {
      display: flex; gap: 10px; flex-wrap: wrap;
      justify-content: center;
    }
    button {
      font-size: 18px; padding: 10px 15px; border: none; border-radius: 6px;
      color: white; background-color: #1e90ff; cursor: pointer; min-width: 100px;
    }
    button:hover { opacity: 0.85; }
    .again { background-color: #e74c3c; } .hard { background-color: #f39c12; }
    .good { background-color: #2ecc71; } .easy { background-color: #3498db; }
    
    #definitions-container {
      max-width: 600px;
      width: 95%;
      margin-top: 10px;
      padding: 5px 15px;
      background-color: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      text-align: left;
      font-size: 16px;
      line-height: 1.7;
      max-height: 40vh;
      overflow-y: auto;
      display: none;
    }
    #definitions-container h4 {
      margin: 10px 0 5px 0;
      font-size: 24px;
      font-weight: normal;
      color: #1e90ff;
      border-bottom: 1px solid #dee2e6;
      padding-bottom: 5px;
    }
    #definitions-container ol {
      padding-left: 25px;
      margin: 0;
    }
    #definitions-container li {
      margin-bottom: 12px;
    }
    #definitions-container .part-of-speech {
      font-weight: bold;
      color: #343a40;
    }
    #definitions-container .example {
      color: #6c757d;
      font-style: italic;
      margin-top: 5px;
      display: block;
    }

    #practice-container {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      min-height: 350px;
      width: 100%;
      box-sizing: border-box;
      justify-content: center;
      padding-top: 20px;
    }
    #stroke-order-animation {
      width: 300px;
      height: 300px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    #practice-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #practice-controls button {
      min-width: 90px;
      font-size: 16px;
      padding: 8px 12px;
    }
    #practice-controls .close-btn {
      background-color: #e74c3c;
    }

    @media (max-width: 768px) {
      body {
        padding: 60px 5px 140px 5px;
      }
      #search-btn, #edit-btn {
        font-size: 24px;
      }
      #main-display-wrapper {
        min-height: 280px;
      }
      #char {
        width: 280px;
        height: 280px;
      }
      #speak-btn, #stroke-btn { 
        font-size: 28px;
      }
      .buttons { 
        gap: 5px; 
      }
      button { 
        font-size: 16px; 
        padding: 8px 10px; 
        min-width: 80px; 
      }
      #stroke-order-animation {
        width: 280px;
        height: 280px;
      }
    }
  </style>
</head>
<body>
  <div id="status-container">
    <span id="status">Loading...</span>
    <span id="sync-status-indicator"></span>
  </div>
  <a id="search-btn" aria-label="Search Character"><i class="ti ti-search"></i></a>
  <a href="edit.html" id="edit-btn" aria-label="Edit Deck & Settings"><i class="ti ti-settings"></i></a>
  
  <div class="main-content">
    <div id="main-display-wrapper">
      <div id="char">Loading...</div>
    </div>
    <div id="practice-container">
      <div id="stroke-order-animation"></div>
      <div id="practice-controls">
        <button onclick="animateAllStrokes()">Animate</button>
        <button onclick="startQuiz()">Practice</button>
        <button class="close-btn" onclick="showStrokeOrder()">Close</button>
      </div>
    </div>
    <div id="definitions-container"></div>
  </div>

  <div class="footer-controls">
    <div id="char-actions-footer">
      <button id="speak-btn" onclick="speakCharacter()" aria-label="Speak"><i class="ti ti-volume"></i></button>
      <button id="stroke-btn" onclick="showStrokeOrder()" aria-label="Show Stroke Order & Practice"><i class="ti ti-writing"></i></button>
    </div>
    <div class="buttons">
      <button id="btn-again" class="again" onclick="rate('again')">Again<br><small>...</small></button>
      <button id="btn-hard" class="hard" onclick="rate('hard')">Hard<br><small>...</small></button>
      <button id="btn-good" class="good" onclick="rate('good')">Good<br><small>...</small></button>
      <button id="btn-easy" class="easy" onclick="rate('easy')">Easy<br><small>...</small></button>
    </div>
  </div>

  <script>
    let cards = {};
    let currentCard = null;
    let isPracticeVisible = false;
    
    const synth = window.speechSynthesis;
    let chineseVoice = null;
    let practiceHanziWriter = null;

    const MOEDICT_API_BASE = 'https://www.moedict.tw/raw/';
    const GIST_FILENAME = 'progress.json';
    const CONSTANTS = {
      AGAIN_INTERVAL: 1, MIN_GOOD_INTERVAL: 10, MIN_EASE: 130, EASY_INITIAL_DAYS: 3,
      EASY_MULTIPLIER: 1.3, HARD_MULTIPLIER: 1.2, MIN_DAY_INTERVAL: 1440,
      EASE_PENALTY_AGAIN: 20, EASE_PENALTY_HARD: 15, EASE_BONUS_EASY: 20
    };
    
    const GIST_API_BASE = 'https://api.github.com/gists/';
    let accessToken = '';
    let gistId = '';

    const footerControls = document.querySelector('.footer-controls');

    // MODIFIED: This function now handles adding a card if it's not found.
    function searchForChar() {
      const charToFindRaw = prompt("Enter a character to search for:");
      if (!charToFindRaw || charToFindRaw.trim().length !== 1) {
        if (charToFindRaw !== null) alert("Please enter a single character.");
        return;
      }
      
      const charToFind = charToFindRaw.trim();
      const foundCard = cards[charToFind];

      if (foundCard) {
        if (isPracticeVisible) showStrokeOrder(); 
        
        currentCard = foundCard;
        displayCharacter(currentCard.char);
        document.getElementById('definitions-container').style.display = 'none';
        document.getElementById('definitions-container').innerHTML = '';
        document.getElementById('main-display-wrapper').style.display = 'flex';
        document.getElementById('practice-container').style.display = 'none';
        footerControls.style.display = 'flex';

        toggleControls(true);
        updateButtonLabels();
      } else {
        // Ask to add the card if not found
        if (confirm(`Character "${charToFind}" not found. Would you like to add it?`)) {
          cards[charToFind] = { char: charToFind, interval: 0, ease: 250, due: Date.now() };
          saveProgress();
          updateStatus();
          alert(`Character "${charToFind}" has been added to your deck!`);
          
          // Immediately show the new card for review
          if (isPracticeVisible) showStrokeOrder(); 
          currentCard = cards[charToFind];
          displayCharacter(currentCard.char);
          document.getElementById('definitions-container').style.display = 'none';
          document.getElementById('definitions-container').innerHTML = '';
          document.getElementById('main-display-wrapper').style.display = 'flex';
          document.getElementById('practice-container').style.display = 'none';
          footerControls.style.display = 'flex';
          toggleControls(true);
          updateButtonLabels();
        }
      }
    }

    function updateSyncStatus(message, isError = false) {
      const statusEl = document.getElementById('sync-status-indicator');
      if (!accessToken || !gistId) {
        statusEl.textContent = 'Local';
        statusEl.style.color = '#f39c12';
        return;
      }
      statusEl.textContent = 'Sync';
      statusEl.style.color = isError ? '#e74c3c' : '#2ecc71';
    }

    async function saveToCloud() {
      if (!accessToken || !gistId) return;
      try {
        const response = await fetch(`${GIST_API_BASE}${gistId}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `token ${accessToken}`, 'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ files: { [GIST_FILENAME]: { content: JSON.stringify(cards) } } })
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        updateSyncStatus('Synced', false);
      } catch (error) {
        console.error('Failed to save to Gist:', error);
        updateSyncStatus('Sync Failed', true);
      }
    }

    async function loadFromCloud() {
      if (!accessToken || !gistId) return false;
      try {
        const response = await fetch(`${GIST_API_BASE}${gistId}`, {
          method: 'GET',
          headers: { 'Authorization': `token ${accessToken}`, 'Accept': 'application/vnd.github.v3+json' }
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        if (data.files && data.files[GIST_FILENAME]) {
            const content = data.files[GIST_FILENAME].content;
            cards = content ? JSON.parse(content) : {};
        }
        updateSyncStatus('Connected', false);
        return true;
      } catch (error) {
        console.error('Failed to load from Gist:', error);
        updateSyncStatus('Connection Failed', true);
        return false;
      }
    }
    
    function loadCredentials() {
      accessToken = localStorage.getItem('ankiAccessToken') || '';
      gistId = localStorage.getItem('ankiGistId') || '';
    }
    
    function setChineseVoice() {
        const setVoice = () => {
            const voices = synth.getVoices();
            chineseVoice = 
                voices.find(voice => voice.name === 'Google 國語（台灣）') || 
                voices.find(voice => voice.lang === 'zh-TW') ||
                voices.find(voice => voice.lang.startsWith('zh-')) ||
                voices.find(voice => voice.lang === 'zh');
        };
        if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = setVoice;
        setVoice();
    }
    setChineseVoice();
    
    function renderDefinitions(data) {
        const container = document.getElementById('definitions-container');
        container.innerHTML = '';
        if (!data || !data.heteronyms) return;

        let content = '';
        data.heteronyms.forEach(h => {
            if (!h.definitions || h.definitions.length === 0) return;
            content += `<h4>${h.bopomofo}</h4><ol>`;
            h.definitions.forEach(def => {
                content += `<li>`;
                if (def.type) content += `<span class="part-of-speech">[${def.type}]</span> `;
                content += def.def;
                if (def.example) def.example.forEach(ex => { content += `<span class="example">例：${ex}</span>`; });
                if (def.quote) def.quote.forEach(q => { content += `<span class="example">引：${q}</span>`; });
                content += `</li>`;
            });
            content += `</ol>`;
        });

        if (content) { container.innerHTML = content; container.style.display = 'block'; }
        else { container.style.display = 'none'; }
    }
    
    async function fetchAndDisplayDetails(char) {
        const container = document.getElementById('definitions-container');
        container.innerHTML = '<h4>Loading...</h4>';
        container.style.display = 'block';

        try {
            if (!char) { container.innerHTML = '<h4>Character missing</h4>'; return; }
            const resp = await fetch(MOEDICT_API_BASE + encodeURIComponent(char));
            if (!resp.ok) { container.innerHTML = `<h4>API Error: HTTP ${resp.status}</h4>`; return; }
            
            const data = await resp.json();
            renderDefinitions(data);
        } catch (error) { 
            console.error("Moedict API failed:", error); 
            container.innerHTML = `<h4>API call failed</h4>`;
        }
    }

    function speakCharacter() {
        if (!currentCard || !currentCard.char) return;
        if (synth.speaking) synth.cancel();

        const utterance = new SpeechSynthesisUtterance(currentCard.char);
        if (chineseVoice) utterance.voice = chineseVoice;
        utterance.lang = 'zh-TW';
        utterance.rate = 0.8;
        synth.speak(utterance);
        
        if (!isPracticeVisible) {
            fetchAndDisplayDetails(currentCard.char);
        }
    }
    
    function showStrokeOrder() {
        const mainDisplayWrapper = document.getElementById('main-display-wrapper');
        const practiceContainer = document.getElementById('practice-container');
        const definitionsEl = document.getElementById('definitions-container');

        if (isPracticeVisible) {
            practiceContainer.style.display = 'none';
            mainDisplayWrapper.style.display = 'flex';
            footerControls.style.display = 'flex';
            if (practiceHanziWriter) {
                document.getElementById('stroke-order-animation').innerHTML = '';
                practiceHanziWriter = null;
            }
            isPracticeVisible = false;
        } else {
            if (!currentCard || !currentCard.char) return;
            mainDisplayWrapper.style.display = 'none';
            footerControls.style.display = 'none';
            definitionsEl.style.display = 'none';
            
            const size = window.innerWidth < 768 ? 280 : 300;
            practiceHanziWriter = HanziWriter.create('stroke-order-animation', currentCard.char, {
                width: size, height: size, padding: 5,
                showOutline: true, strokeAnimationSpeed: 0.5, delayBetweenStrokes: 100,
                strokeColor: '#000000'
            });
            practiceHanziWriter.animateCharacter();

            practiceContainer.style.display = 'flex';
            isPracticeVisible = true;
        }
    }

    function animateAllStrokes() {
        if (practiceHanziWriter) practiceHanziWriter.animateCharacter();
    }
    function startQuiz() {
        if (practiceHanziWriter) practiceHanziWriter.quiz();
    }
    
    function displayCharacter(character) {
        const charEl = document.getElementById('char');
        charEl.innerHTML = ''; 
        charEl.style.fontSize = 'var(--char-size-desktop)';
        
        if (character) {
            const size = window.innerWidth < 768 ? 280 : 350;
            HanziWriter.create('char', character, {
                width: size, height: size, padding: 0, showOutline: false,
                strokeColor: '#000000'
            });
        } else {
            charEl.style.fontSize = '24px';
            charEl.textContent = "All cards reviewed for now!";
        }
    }

    function minutesToMs(mins) { return mins * 60 * 1000; }
    function formatInterval(minutes) {
      if (minutes < 60) return `${Math.max(1, Math.round(minutes))}m`;
      const hours = minutes / 60;
      return hours < 24 ? `${Math.round(hours)}h` : `${Math.round(hours / 24)}d`;
    }
    function saveProgress() {
      if (accessToken && gistId) saveToCloud();
      else localStorage.setItem("ankiCards", JSON.stringify(cards));
    }
    async function loadProgress() {
      const cloudSuccess = await loadFromCloud();
      if (!cloudSuccess) {
        const saved = localStorage.getItem("ankiCards");
        if (saved) cards = JSON.parse(saved);
      }
      updateSyncStatus();
    }
    function calculateNextState(card, action) {
        let newInterval, newEase = card.ease;
        const good = card.interval < CONSTANTS.MIN_GOOD_INTERVAL ? CONSTANTS.MIN_GOOD_INTERVAL : card.interval * (card.ease / 100);
        switch(action) {
            case "again": newInterval = CONSTANTS.AGAIN_INTERVAL; newEase = Math.max(CONSTANTS.MIN_EASE, newEase - CONSTANTS.EASE_PENALTY_AGAIN); break;
            case "hard": newInterval = (CONSTANTS.AGAIN_INTERVAL + good) / 2 * CONSTANTS.HARD_MULTIPLIER; newEase = Math.max(CONSTANTS.MIN_EASE, newEase - CONSTANTS.EASE_PENALTY_HARD); break;
            case "good": newInterval = good; break;
            case "easy": newInterval = (card.interval < CONSTANTS.MIN_DAY_INTERVAL ? CONSTANTS.MIN_DAY_INTERVAL * CONSTANTS.EASY_INITIAL_DAYS : good * CONSTANTS.EASY_MULTIPLIER); newEase += CONSTANTS.EASE_BONUS_EASY; break;
        }
        return { interval: Math.round(newInterval), ease: newEase };
    }
    function updateButtonLabels() {
        ['again', 'hard', 'good', 'easy'].forEach(action => {
            const small = document.getElementById(`btn-${action}`).querySelector('small');
            small.textContent = currentCard ? formatInterval(calculateNextState(currentCard, action).interval) : '---';
        });
    }
    function toggleControls(enabled) {
      [document.getElementById('speak-btn'), document.getElementById('stroke-btn')].forEach(btn => {
        btn.disabled = !enabled; btn.style.opacity = enabled ? 1.0 : 0.5;
        btn.style.cursor = enabled ? 'pointer' : 'default';
      });
    }
    async function initializeDeck() {
      await loadProgress();
      try {
        const response = await fetch("chars.txt");
        if (response.ok) {
            const text = await response.text();
            const chars = text.split(/\r?\n/).map(c => c.trim()).filter(c => c.length === 1);
            let newCardsAdded = chars.reduce((count, c) => {
              if (!cards[c]) { cards[c] = { char: c, interval: 0, ease: 250, due: Date.now() }; return count + 1; }
              return count;
            }, 0);
            if (newCardsAdded > 0) saveProgress();
        }
      } catch (error) { 
        console.error("chars.txt not found or failed to load.", error);
      } finally {
        updateStatus();
        if (Object.keys(cards).length > 0) {
            showNextCard();
        } else {
            const charEl = document.getElementById("char");
            charEl.innerHTML = '';
            charEl.style.fontSize = '24px';
            charEl.textContent = "Deck is empty. Add cards in \"Edit Deck & Settings\".";
            currentCard = null;
            toggleControls(false);
            updateButtonLabels();
        }
        document.querySelector('.main-content').style.opacity = 1;
      }
    }
    function updateStatus() {
      const total = Object.keys(cards).length;
      const dueNow = Object.values(cards).filter(c => c.due <= Date.now()).length;
      document.getElementById("status").textContent = `Due: ${dueNow} / Total: ${total}`;
    }
    function showNextCard() {
      if (isPracticeVisible) {
        showStrokeOrder();
      }
      
      const definitionsEl = document.getElementById('definitions-container');
      definitionsEl.style.display = 'none';
      definitionsEl.innerHTML = '';
      
      const dueCards = Object.values(cards).filter(c => c.due <= Date.now());
      if (dueCards.length > 0) {
        currentCard = dueCards[Math.floor(Math.random() * dueCards.length)];
      } else if (Object.keys(cards).length > 0) {
        currentCard = Object.values(cards).sort((a, b) => a.due - b.due)[0];
      } else {
        currentCard = null;
      }
      
      if (currentCard) {
        displayCharacter(currentCard.char);
        toggleControls(true);
      } else {
        displayCharacter(null);
        toggleControls(false);
      }

      updateStatus(); 
      updateButtonLabels();
    }
    function rate(action) {
      if (!currentCard) return;
      const { interval, ease } = calculateNextState(currentCard, action);
      currentCard.interval = interval; currentCard.ease = ease;
      currentCard.due = Date.now() + minutesToMs(interval);
      saveProgress(); 
      showNextCard();
    }
    
    loadCredentials();
    document.getElementById('search-btn').addEventListener('click', searchForChar);
    initializeDeck();
  </script>
</body>
</html>